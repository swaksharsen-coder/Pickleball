<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>UA Pickleball Database</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --accent: #22c55e;
      --bg-gradient-start: #0f172a;
      --bg-gradient-end: #1e293b;
      --card-bg: #f9fafb;
      --border-soft: #e5e7eb;
      --text-main: #111827;
      --text-muted: #6b7280;
      --tab-bg: #e5edff;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      color: var(--text-main);
      background: radial-gradient(circle at top, #1e293b, #020617);
    }

    .container {
      max-width: 1160px;
      margin: 24px auto 40px;
      background: linear-gradient(180deg, #ffffff, #f9fafb);
      padding: 24px 28px 32px;
      border-radius: 20px;
      box-shadow:
        0 24px 60px rgba(15, 23, 42, 0.35),
        0 0 0 1px rgba(148, 163, 184, 0.3);
    }

    h1 {
      text-align: center;
      margin: 0 0 8px;
      font-size: 1.9rem;
      letter-spacing: 0.03em;
      color: #0f172a;
    }

    h2 {
      text-align: center;
      margin-top: 0;
      font-size: 1.25rem;
      color: #111827;
    }

    .subtitle {
      text-align: center;
      margin: 0 0 18px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    /* TABS */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 18px;
      flex-wrap: wrap;
      padding: 4px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.08);
    }

    .tab-button {
      padding: 7px 14px;
      border-radius: 999px;
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--primary-dark);
      position: relative;
      transition: background 0.15s ease, color 0.15s ease, transform 0.1s ease;
    }

    .tab-button::before {
      content: "";
      position: absolute;
      inset: 3px;
      border-radius: 999px;
      background: transparent;
      z-index: -1;
      transition: background 0.15s ease;
    }

    .tab-button:hover::before {
      background: rgba(37, 99, 235, 0.1);
    }

    .tab-button.active {
      color: #ffffff;
      background: var(--primary);
      box-shadow: 0 6px 18px rgba(37, 99, 235, 0.4);
      transform: translateY(-1px);
    }

    .tab-button.active::before {
      background: transparent;
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.18s ease-out;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .flex {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-top: 10px;
    }

    .card {
      flex: 1 1 300px;
      background: var(--card-bg);
      padding: 14px 18px 16px;
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
    }

    label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.85rem;
      font-weight: 600;
      color: #111827;
    }

    input, select, button {
      width: 100%;
      padding: 7px 9px;
      margin-bottom: 10px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
      box-sizing: border-box;
      font-family: inherit;
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.3);
    }

    button {
      cursor: pointer;
      border: none;
      font-weight: 600;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: #fff;
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(37, 99, 235, 0.35);
    }

    button[disabled] {
      background: #9ca3af;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 0.9rem;
      background: #ffffff;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
    }

    th, td {
      padding: 7px 8px;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
    }

    th {
      background: #f3f4f6;
      font-weight: 700;
      font-size: 0.85rem;
      color: #374151;
    }

    tr:nth-child(even) {
      background: #f9fafb;
    }

    tr:hover td {
      background: #eef2ff;
    }

    .msg {
      font-size: 0.85rem;
      margin-top: 5px;
    }

    .msg.error {
      color: #b91c1c;
    }

    .msg.success {
      color: #15803d;
    }

    .small {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 5px;
    }

    .admin-only {
      display: none;
    }

    .delete-btn {
      width: auto;
      padding: 3px 8px;
      font-size: 0.75rem;
      background: #ef4444;
      color: #fff;
      border-radius: 999px;
    }

    .sort-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 10px;
      margin-bottom: 5px;
      align-items: center;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .sort-row select {
      width: auto;
      min-width: 150px;
    }

    #ratingCurveCanvas {
      width: 100%;
      height: 260px;
    }

    .auth-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 6px;
    }

    .google-btn {
      background: #ffffff;
      border: 1px solid #d1d5db;
      color: #374151;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .google-btn:hover {
      background: #f3f4f6;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.1);
    }

    .admin-tab {
      display: none;
    }

    #logoutBtn {
      display: none;
    }

    @media (max-width: 700px) {
      th, td { font-size: 0.8rem; }
      h1 { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>UA Pickleball Database</h1>
    <p class="subtitle">Ratings, match history, and stats for 2v2 pickleball at UA.</p>

    <!-- NAV TABS -->
    <div class="tabs">
      <button class="tab-button active" data-tab="matches">Matches</button>
      <button class="tab-button" data-tab="players">Players</button>
      <button class="tab-button" data-tab="stats">Stats</button>
      <button class="tab-button" data-tab="teams">Team Suggestion</button>
      <button class="tab-button" data-tab="curves">Rating Curves</button>
      <button class="tab-button" data-tab="signin">Sign In</button>
      <button class="tab-button admin-tab" data-tab="admin">Admin</button>
    </div>

    <!-- TAB: MATCHES -->
    <div id="tab-matches" class="tab-content active">
      <div class="flex">
        <div class="card">
          <h2 style="font-size:1.1rem; text-align:left;">Record 2 vs 2 Match</h2>

          <label>Team 1 – Player 1</label>
          <select id="team1p1"></select>

          <label>Team 1 – Player 2</label>
          <select id="team1p2"></select>

          <label>Team 2 – Player 1</label>
          <select id="team2p1"></select>

          <label>Team 2 – Player 2</label>
          <select id="team2p2"></select>

          <button id="predictBtn" type="button">Predict Winning %</button>
          <div id="predictionDisplay" class="msg"></div>

          <label for="score1">Final Score (Team 1)</label>
          <input type="number" id="score1" placeholder="e.g. 11" />

          <label for="score2">Final Score (Team 2)</label>
          <input type="number" id="score2" placeholder="e.g. 9" />

          <button id="recordMatchBtn">Record Match (Winner auto-detected)</button>
          <div id="matchMessage" class="msg"></div>
        </div>
      </div>

      <h2 style="margin-top:25px;">Match History</h2>
      <div class="sort-row">
        <label>Sort by date:</label>
        <select id="matchSort">
          <option value="newest">Newest first</option>
          <option value="oldest">Oldest first</option>
        </select>
      </div>
      <table id="matchesTable">
        <thead>
          <tr>
            <th>Date &amp; Time</th>
            <th>Team 1</th>
            <th>Team 2</th>
            <th>Winner</th>
            <th>Score</th>
            <th class="admin-only">Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- TAB: PLAYERS -->
    <div id="tab-players" class="tab-content">
      <h2>Players</h2>
      <div class="sort-row">
        <label>Sort players by:</label>
        <select id="playerSort">
          <option value="ratingDesc">Rating (high → low)</option>
          <option value="ratingAsc">Rating (low → high)</option>
          <option value="winsDesc">Wins (high → low)</option>
          <option value="nameAsc">Name (A → Z)</option>
        </select>
      </div>
      <table id="playersTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Player Rating</th>
            <th>Wins</th>
            <th>Losses</th>
            <th>Matches</th>
            <th>Win %</th>
            <th>Clean Wins (Opp. 0)</th>
            <th>Losses to 0 (Scored 0)</th>
            <th class="admin-only">Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- TAB: STATS -->
    <div id="tab-stats" class="tab-content">
      <h2>Player Statistics</h2>
      <div class="card">
        <label for="statsPlayerSelect">Select Player</label>
        <select id="statsPlayerSelect"></select>
        <button id="loadStatsBtn">Load Stats</button>
        <div id="statsMessage" class="msg"></div>
      </div>

      <div class="card" style="margin-top:15px;">
        <h3 style="text-align:left; margin-top:0;">Summary</h3>
        <div id="statsSummary"></div>
      </div>

      <h3 style="margin-top:20px;">Matches for Selected Player</h3>
      <div class="sort-row">
        <label for="statsFilter">Show:</label>
        <select id="statsFilter">
          <option value="all">All Matches</option>
          <option value="shutoutWins">Clean Wins (Opponent 0)</option>
          <option value="shutoutLosses">Losses to 0 (Scored 0)</option>
        </select>
      </div>
      <table id="playerMatchesTable">
        <thead>
          <tr>
            <th>Date &amp; Time</th>
            <th>Team 1</th>
            <th>Team 2</th>
            <th>Result</th>
            <th>Score</th>
            <th>Rating After</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- TAB: TEAM SUGGESTION -->
    <div id="tab-teams" class="tab-content">
      <h2>Best Team Combination (2 vs 2)</h2>
      <div class="card">
        <label for="availablePlayers">Select available players (Ctrl/Shift + click to select multiple)</label>
        <select id="availablePlayers" multiple size="8"></select>
        <button id="suggestTeamsBtn">Suggest Best Match</button>
        <div id="teamSuggestion" class="msg"></div>
      </div>
    </div>

    <!-- TAB: RATING CURVES -->
    <div id="tab-curves" class="tab-content">
      <h2>Rating Curves</h2>
      <div class="card">
        <label for="ratingCurvePlayerSelect">Select Player</label>
        <select id="ratingCurvePlayerSelect"></select>
        <button id="showCurveBtn">Show Rating Curve</button>
        <div id="curveMessage" class="msg"></div>
      </div>
      <div class="card" style="margin-top:15px;">
        <canvas id="ratingCurveCanvas"></canvas>
      </div>
    </div>

    <!-- TAB: SIGN IN -->
    <div id="tab-signin" class="tab-content">
      <div class="flex">
        <div class="card" style="max-width:420px;">
          <h2 style="font-size:1.1rem; text-align:left;">Sign In / Account</h2>

          <div id="authFormContainer">
            <label for="adminEmail">Email</label>
            <input type="email" id="adminEmail" placeholder="you@example.com" />
            <label for="adminPassword">Password</label>
            <input type="password" id="adminPassword" placeholder="Password" />

            <div class="auth-buttons">
              <button id="loginBtn">Login</button>
              <button id="signupBtn" style="background:#22c55e;">Create Account</button>
              <button id="resetPasswordBtn" style="background:#6b7280;">Send Password Reset Email</button>
              <button id="googleLoginBtn" class="google-btn" type="button">
                <span>Sign in with Google</span>
              </button>
            </div>
          </div>

          <button id="logoutBtn" style="background:#dc2626; margin-top:10px;">
            Log out / Sign in a different account
          </button>

          <div id="authMessage" class="msg"></div>
          <p class="small" id="adminStatus">Not logged in.</p>
        </div>
      </div>
    </div>

    <!-- TAB: ADMIN (only visible if isAdmin = true) -->
    <div id="tab-admin" class="tab-content">
      <div class="flex">
        <!-- PLAYER MGMT -->
        <div class="card admin-only">
          <h2 style="font-size:1.1rem; text-align:left;">Player Management</h2>
          <label for="newPlayerName">Add New Player</label>
          <input type="text" id="newPlayerName" placeholder="e.g., John Doe" />
          <button id="addPlayerBtn">Add Player</button>
          <div id="playerMessage" class="msg"></div>
        </div>

        <!-- ADMIN MGMT -->
        <div class="card admin-only">
          <h2 style="font-size:1.1rem; text-align:left;">Admin Management</h2>
          <label for="newAdminEmail">Add New Admin by Email</label>
          <input type="email" id="newAdminEmail" placeholder="user@example.com" />
          <button id="addAdminBtn">Add Admin</button>
          <div id="adminManageMessage" class="msg"></div>
        </div>

        <!-- PLAYER STAT EDIT -->
        <div class="card admin-only">
          <h2 style="font-size:1.1rem; text-align:left;">Edit Player Stats</h2>
          <label for="editPlayerSelect">Select Player</label>
          <select id="editPlayerSelect"></select>

          <label for="editPlayerRating">Player Rating</label>
          <input type="number" id="editPlayerRating" />

          <label for="editPlayerWins">Wins</label>
          <input type="number" id="editPlayerWins" />

          <label for="editPlayerLosses">Losses</label>
          <input type="number" id="editPlayerLosses" />

          <label for="editPlayerMatches">Matches</label>
          <input type="number" id="editPlayerMatches" />

          <button id="savePlayerStatsBtn">Save Player Stats</button>
          <div id="editPlayerMessage" class="msg"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <!-- Chart.js for rating curves -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCxH9Zda7Yx31CN3jimkUZkuDEg4ecaqQ8",
      authDomain: "pickleball-elo.firebaseapp.com",
      projectId: "pickleball-elo",
      storageBucket: "pickleball-elo.firebasestorage.app",
      messagingSenderId: "115251632176",
      appId: "1:115251632176:web:20c5cd2a72ad37c44bf5f5"
    };
    const MASTER_ADMIN_EMAIL = "swaksharsen@gmail.com";
    const BASE_RATING = 1600;

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();

    // Tabs
    const tabButtons = document.querySelectorAll(".tab-button");
    const tabContents = {
      matches: document.getElementById("tab-matches"),
      players: document.getElementById("tab-players"),
      stats: document.getElementById("tab-stats"),
      teams: document.getElementById("tab-teams"),
      curves: document.getElementById("tab-curves"),
      signin: document.getElementById("tab-signin"),
      admin: document.getElementById("tab-admin")
    };
    const adminTabButton = document.querySelector(".tab-button.admin-tab");

    tabButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const tab = btn.getAttribute("data-tab");
        tabButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        Object.keys(tabContents).forEach(k => tabContents[k].classList.remove("active"));
        tabContents[tab].classList.add("active");
      });
    });

    // DOM refs
    const adminEmailInput = document.getElementById("adminEmail");
    const adminPasswordInput = document.getElementById("adminPassword");
    const loginBtn = document.getElementById("loginBtn");
    const signupBtn = document.getElementById("signupBtn");
    const resetPasswordBtn = document.getElementById("resetPasswordBtn");
    const googleLoginBtn = document.getElementById("googleLoginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const authFormContainer = document.getElementById("authFormContainer");
    const authMessageDiv = document.getElementById("authMessage");
    const adminStatusP = document.getElementById("adminStatus");

    const newPlayerNameInput = document.getElementById("newPlayerName");
    const addPlayerBtn = document.getElementById("addPlayerBtn");
    const playerMessageDiv = document.getElementById("playerMessage");

    const newAdminEmailInput = document.getElementById("newAdminEmail");
    const addAdminBtn = document.getElementById("addAdminBtn");
    const adminManageMessageDiv = document.getElementById("adminManageMessage");

    const team1p1Select = document.getElementById("team1p1");
    const team1p2Select = document.getElementById("team1p2");
    const team2p1Select = document.getElementById("team2p1");
    const team2p2Select = document.getElementById("team2p2");
    const predictBtn = document.getElementById("predictBtn");
    const predictionDisplay = document.getElementById("predictionDisplay");
    const score1Input = document.getElementById("score1");
    const score2Input = document.getElementById("score2");
    const recordMatchBtn = document.getElementById("recordMatchBtn");
    const matchMessageDiv = document.getElementById("matchMessage");
    const matchSortSelect = document.getElementById("matchSort");
    const matchesBody = document.querySelector("#matchesTable tbody");

    const playersBody = document.querySelector("#playersTable tbody");
    const playerSortSelect = document.getElementById("playerSort");

    const statsPlayerSelect = document.getElementById("statsPlayerSelect");
    const loadStatsBtn = document.getElementById("loadStatsBtn");
    const statsMessageDiv = document.getElementById("statsMessage");
    const statsSummaryDiv = document.getElementById("statsSummary");
    const statsFilterSelect = document.getElementById("statsFilter");
    const playerMatchesBody = document.querySelector("#playerMatchesTable tbody");

    const availablePlayersSelect = document.getElementById("availablePlayers");
    const suggestTeamsBtn = document.getElementById("suggestTeamsBtn");
    const teamSuggestionDiv = document.getElementById("teamSuggestion");

    const ratingCurvePlayerSelect = document.getElementById("ratingCurvePlayerSelect");
    const showCurveBtn = document.getElementById("showCurveBtn");
    const curveMessageDiv = document.getElementById("curveMessage");
    const ratingCurveCanvas = document.getElementById("ratingCurveCanvas");

    const editPlayerSelect = document.getElementById("editPlayerSelect");
    const editPlayerRatingInput = document.getElementById("editPlayerRating");
    const editPlayerWinsInput = document.getElementById("editPlayerWins");
    const editPlayerLossesInput = document.getElementById("editPlayerLosses");
    const editPlayerMatchesInput = document.getElementById("editPlayerMatches");
    const savePlayerStatsBtn = document.getElementById("savePlayerStatsBtn");
    const editPlayerMessageDiv = document.getElementById("editPlayerMessage");

    let ratingCurveChart = null;

    let currentUser = null;
    let isAdmin = false;
    let players = [];
    let matchesGlobal = [];

    let statsCurrentMatches = [];
    let statsCurrentPlayerId = null;

    // Audit logging helper
    function logAction(action, details = {}) {
      if (!currentUser) return Promise.resolve();
      return db.collection("auditLogs").add({
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        userEmail: currentUser.email || null,
        userUid: currentUser.uid || null,
        action,
        details
      }).catch(err => {
        console.error("Audit log error:", err);
      });
    }

    // Utils
    function timeString(ts) {
      const d = ts && ts.toDate ? ts.toDate() : new Date();
      return d.toLocaleString();
    }

    function setAdminUI(visible) {
      document.querySelectorAll(".admin-only").forEach(el => {
        if (el.tagName === "TD" || el.tagName === "TH") {
          el.style.display = visible ? "table-cell" : "none";
        } else {
          el.style.display = visible ? "block" : "none";
        }
      });
      if (adminTabButton) {
        adminTabButton.style.display = visible ? "inline-block" : "none";
      }
    }

    function playerWinPercent(p) {
      const total = (p.matches ?? (p.wins + p.losses));
      if (!total) return "0%";
      return ((p.wins / total) * 100).toFixed(1) + "%";
    }

    function teamLabel(teamIds) {
      return teamIds
        .map(id => players.find(p => p.id === id)?.name || id)
        .join(" & ");
    }

    function expectedScore(rA, rB) {
      return 1 / (1 + Math.pow(10, (rB - rA) / 400));
    }

    function teamRating(playerIds) {
      const ratings = playerIds
        .map(id => players.find(p => p.id === id))
        .filter(Boolean)
        .map(p => p.rating);
      if (!ratings.length) return BASE_RATING;
      return ratings.reduce((a,b)=>a+b,0) / ratings.length;
    }

    function clearAuthMessage() {
      authMessageDiv.textContent = "";
      authMessageDiv.className = "msg";
    }

    // Auth actions
    loginBtn.addEventListener("click", () => {
      clearAuthMessage();
      const email = adminEmailInput.value.trim();
      const pass = adminPasswordInput.value.trim();
      if (!email || !pass) {
        authMessageDiv.textContent = "Enter email and password.";
        authMessageDiv.classList.add("error");
        return;
      }
      auth.signInWithEmailAndPassword(email, pass)
        .then(() => {
          authMessageDiv.textContent = "Login successful.";
          authMessageDiv.classList.add("success");
        })
        .catch(err => {
          authMessageDiv.textContent = "Login failed: " + err.message;
          authMessageDiv.classList.add("error");
        });
    });

    signupBtn.addEventListener("click", () => {
      clearAuthMessage();
      const email = adminEmailInput.value.trim();
      const pass = adminPasswordInput.value.trim();
      if (!email || !pass) {
        authMessageDiv.textContent = "Enter email and password to create account.";
        authMessageDiv.classList.add("error");
        return;
      }
      auth.createUserWithEmailAndPassword(email, pass)
        .then(() => {
          authMessageDiv.textContent = "Account created and logged in.";
          authMessageDiv.classList.add("success");
        })
        .catch(err => {
          authMessageDiv.textContent = "Sign up failed: " + err.message;
          authMessageDiv.classList.add("error");
        });
    });

    resetPasswordBtn.addEventListener("click", () => {
      clearAuthMessage();
      const email = adminEmailInput.value.trim();
      if (!email) {
        authMessageDiv.textContent = "Enter your email to reset password.";
        authMessageDiv.classList.add("error");
        return;
      }
      auth.sendPasswordResetEmail(email)
        .then(() => {
          authMessageDiv.textContent = "Password reset email sent.";
          authMessageDiv.classList.add("success");
        })
        .catch(err => {
          authMessageDiv.textContent = "Reset failed: " + err.message;
          authMessageDiv.classList.add("error");
        });
    });

    googleLoginBtn.addEventListener("click", () => {
      clearAuthMessage();
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider)
        .then(() => {
          authMessageDiv.textContent = "Google login successful.";
          authMessageDiv.classList.add("success");
        })
        .catch(err => {
          authMessageDiv.textContent = "Google login failed: " + err.message;
          authMessageDiv.classList.add("error");
        });
    });

    logoutBtn.addEventListener("click", () => auth.signOut());

    async function checkAdmin(user) {
      if (!user) {
        currentUser = null;
        isAdmin = false;
        adminStatusP.textContent = "Not logged in.";
        setAdminUI(false);
        authFormContainer.style.display = "block";
        logoutBtn.style.display = "none";
        return;
      }
      currentUser = user;

      // Toggle sign-in UI
      authFormContainer.style.display = "none";
      logoutBtn.style.display = "block";

      if (user.email === MASTER_ADMIN_EMAIL) {
        isAdmin = true;
        adminStatusP.textContent = "Logged in as master admin: " + user.email;
        setAdminUI(true);
        return;
      }
      try {
        const doc = await db.collection("admins").doc(user.email).get();
        isAdmin = doc.exists;
      } catch (e) {
        console.error(e);
        isAdmin = false;
      }
      if (isAdmin) {
        adminStatusP.textContent = "Logged in as admin: " + user.email;
      } else {
        adminStatusP.textContent = "Logged in: " + user.email + " (not admin)";
      }
      setAdminUI(isAdmin);
    }

    auth.onAuthStateChanged(user => {
      clearAuthMessage();
      checkAdmin(user);
    });

    // Player management (admin)
    addPlayerBtn.addEventListener("click", async () => {
      playerMessageDiv.textContent = "";
      playerMessageDiv.className = "msg";
      if (!currentUser) {
        playerMessageDiv.textContent = "Login required.";
        playerMessageDiv.classList.add("error");
        return;
      }
      if (!isAdmin) {
        playerMessageDiv.textContent = "Only admins can add players.";
        playerMessageDiv.classList.add("error");
        return;
      }
      const name = newPlayerNameInput.value.trim();
      if (!name) {
        playerMessageDiv.textContent = "Player name is required.";
        playerMessageDiv.classList.add("error");
        return;
      }
      try {
        const ref = await db.collection("players").add({
          name,
          rating: BASE_RATING,
          wins: 0,
          losses: 0,
          matches: 0
        });
        await logAction("ADD_PLAYER", { playerId: ref.id, name });
        newPlayerNameInput.value = "";
        playerMessageDiv.textContent = "Player added.";
        playerMessageDiv.classList.add("success");
      } catch (err) {
        playerMessageDiv.textContent = "Error: " + err.message;
        playerMessageDiv.classList.add("error");
      }
    });

    async function deletePlayer(id) {
      if (!currentUser || !isAdmin) return;
      if (!confirm("Delete this player? (Matches remain; ratings not undone)")) return;
      try {
        await db.collection("players").doc(id).delete();
        await logAction("DELETE_PLAYER", { playerId: id });
      } catch (err) {
        alert("Error deleting player: " + err.message);
      }
    }

    // Admin management
    addAdminBtn.addEventListener("click", async () => {
      adminManageMessageDiv.textContent = "";
      adminManageMessageDiv.className = "msg";
      if (!currentUser) {
        adminManageMessageDiv.textContent = "Login required.";
        adminManageMessageDiv.classList.add("error");
        return;
      }
      if (!isAdmin) {
        adminManageMessageDiv.textContent = "Only admins can add admins.";
        adminManageMessageDiv.classList.add("error");
        return;
      }
      const email = newAdminEmailInput.value.trim();
      if (!email) {
        adminManageMessageDiv.textContent = "Please enter an email.";
        adminManageMessageDiv.classList.add("error");
        return;
      }
      try {
        await db.collection("admins").doc(email).set({
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        await logAction("ADD_ADMIN", { adminEmail: email });
        adminManageMessageDiv.textContent = "Admin added: " + email;
        adminManageMessageDiv.classList.add("success");
        newAdminEmailInput.value = "";
      } catch (err) {
        adminManageMessageDiv.textContent = "Error: " + err.message;
        adminManageMessageDiv.classList.add("error");
      }
    });

    // Player data listener
    db.collection("players").onSnapshot(snapshot => {
      players = [];
      snapshot.forEach(doc => players.push({ id: doc.id, ...doc.data() }));
      fillTeamSelects();
      renderPlayersTable();
      fillStatsPlayerSelect();
      renderMatchesTable();
      fillAvailablePlayersSelect();
      fillRatingCurveSelect();
      fillEditPlayerSelect();
    });

    function fillTeamSelects() {
      const sels = [team1p1Select, team1p2Select, team2p1Select, team2p2Select];
      sels.forEach(sel => {
        sel.innerHTML = "<option value=''>-- Select Player --</option>";
        players.forEach(p => {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = p.name + " (" + p.rating + ")";
          sel.appendChild(opt);
        });
      });
    }

    function computeNilStatsForPlayers() {
      const stats = {};
      players.forEach(p => {
        stats[p.id] = { shutoutWins: 0, shutoutLosses: 0 };
      });

      matchesGlobal.forEach(m => {
        if (m.score1 == null || m.score2 == null) return;
        const t1 = m.team1 || [];
        const t2 = m.team2 || [];
        const s1 = m.score1;
        const s2 = m.score2;

        t1.forEach(pid => {
          if (!stats[pid]) stats[pid] = { shutoutWins: 0, shutoutLosses: 0 };
          if (s1 > 0 && s2 === 0) stats[pid].shutoutWins++;
          if (s1 === 0 && s2 > 0) stats[pid].shutoutLosses++;
        });
        t2.forEach(pid => {
          if (!stats[pid]) stats[pid] = { shutoutWins: 0, shutoutLosses: 0 };
          if (s2 > 0 && s1 === 0) stats[pid].shutoutWins++;
          if (s2 === 0 && s1 > 0) stats[pid].shutoutLosses++;
        });
      });

      return stats;
    }

    function renderPlayersTable() {
      playersBody.innerHTML = "";
      let arr = [...players];
      const sortVal = playerSortSelect.value;
      if (sortVal === "ratingDesc") arr.sort((a,b)=>b.rating-a.rating);
      if (sortVal === "ratingAsc") arr.sort((a,b)=>a.rating-b.rating);
      if (sortVal === "winsDesc") arr.sort((a,b)=>b.wins-a.wins);
      if (sortVal === "nameAsc") arr.sort((a,b)=>a.name.localeCompare(b.name));

      const nilStats = computeNilStatsForPlayers();

      arr.forEach(p => {
        const totalMatches = p.matches ?? (p.wins + p.losses);
        const ns = nilStats[p.id] || { shutoutWins: 0, shutoutLosses: 0 };
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${p.name}</td>
          <td>${p.rating}</td>
          <td>${p.wins}</td>
          <td>${p.losses}</td>
          <td>${totalMatches}</td>
          <td>${playerWinPercent(p)}</td>
          <td>${ns.shutoutWins}</td>
          <td>${ns.shutoutLosses}</td>
          <td class="admin-only"></td>
        `;
        if (isAdmin) {
          const actionsCell = tr.lastElementChild;
          const delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.className = "delete-btn";
          delBtn.addEventListener("click", () => deletePlayer(p.id));
          actionsCell.appendChild(delBtn);
        }
        playersBody.appendChild(tr);
      });
      setAdminUI(isAdmin);
    }
    playerSortSelect.addEventListener("change", renderPlayersTable);

    // Matches listener
    db.collection("matches")
      .orderBy("timestamp", "desc")
      .limit(300)
      .onSnapshot(snapshot => {
        matchesGlobal = [];
        snapshot.forEach(doc => matchesGlobal.push({ id: doc.id, ...doc.data() }));
        renderPlayersTable();
        renderMatchesTable();
      });

    function renderMatchesTable() {
      matchesBody.innerHTML = "";
      let arr = [...matchesGlobal];
      const sortVal = matchSortSelect.value;
      arr.sort((a,b) => {
        const ta = a.timestamp?.toMillis ? a.timestamp.toMillis() : 0;
        const tb = b.timestamp?.toMillis ? b.timestamp.toMillis() : 0;
        return (sortVal === "newest") ? (tb - ta) : (ta - tb);
      });
      arr.forEach(m => {
        const tr = document.createElement("tr");
        const t1 = m.team1 || [];
        const t2 = m.team2 || [];
        const team1Label = teamLabel(t1);
        const team2Label = teamLabel(t2);
        const winnerLabel = (m.winner === "team1") ? team1Label : team2Label;
        const scoreStr = (m.score1 != null && m.score2 != null)
          ? `${m.score1} - ${m.score2}` : "-";
        tr.innerHTML = `
          <td>${m.timestamp ? timeString(m.timestamp) : ""}</td>
          <td>${team1Label}</td>
          <td>${team2Label}</td>
          <td>${winnerLabel}</td>
          <td>${scoreStr}</td>
          <td class="admin-only"></td>
        `;
        if (isAdmin) {
          const td = tr.lastElementChild;
          const delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.className = "delete-btn";
          delBtn.addEventListener("click", () => deleteMatch(m.id));
          td.appendChild(delBtn);
        }
        matchesBody.appendChild(tr);
      });
      setAdminUI(isAdmin);
    }
    matchSortSelect.addEventListener("change", renderMatchesTable);

    async function deleteMatch(id) {
      if (!currentUser || !isAdmin) return;
      if (!confirm("Delete this match? Ratings will NOT be undone.")) return;
      try {
        await db.collection("matches").doc(id).delete();
        await logAction("DELETE_MATCH", { matchId: id });
      } catch (err) {
        alert("Error deleting match: " + err.message);
      }
    }

    // Predict winning %
    predictBtn.addEventListener("click", () => {
      predictionDisplay.textContent = "";
      predictionDisplay.className = "msg";

      const t1 = [team1p1Select.value, team1p2Select.value].filter(Boolean);
      const t2 = [team2p1Select.value, team2p2Select.value].filter(Boolean);

      if (t1.length !== 2 || t2.length !== 2) {
        predictionDisplay.textContent = "Select 2 players for each team.";
        predictionDisplay.classList.add("error");
        return;
      }
      const all = [...t1, ...t2];
      if (new Set(all).size !== all.length) {
        predictionDisplay.textContent = "A player cannot be on both teams.";
        predictionDisplay.classList.add("error");
        return;
      }

      const r1 = teamRating(t1);
      const r2 = teamRating(t2);
      const P1 = expectedScore(r1, r2);
      const P2 = 1 - P1;

      predictionDisplay.innerHTML =
        `<b>${teamLabel(t1)}</b> Win Chance: <b>${(P1*100).toFixed(1)}%</b><br>` +
        `<b>${teamLabel(t2)}</b> Win Chance: <b>${(P2*100).toFixed(1)}%</b>`;
      predictionDisplay.classList.add("success");
    });

    // Record match – any logged-in user
    recordMatchBtn.addEventListener("click", async () => {
      matchMessageDiv.textContent = "";
      matchMessageDiv.className = "msg";

      if (!currentUser) {
        matchMessageDiv.textContent = "Login required to record matches.";
        matchMessageDiv.classList.add("error");
        return;
      }

      const t1 = [team1p1Select.value, team1p2Select.value].filter(Boolean);
      const t2 = [team2p1Select.value, team2p2Select.value].filter(Boolean);
      if (t1.length !== 2 || t2.length !== 2) {
        matchMessageDiv.textContent = "Each team must have exactly 2 players.";
        matchMessageDiv.classList.add("error");
        return;
      }
      const all = [...t1, ...t2];
      if (new Set(all).size !== all.length) {
        matchMessageDiv.textContent = "A player cannot be on both teams.";
        matchMessageDiv.classList.add("error");
        return;
      }

      const s1 = parseInt(score1Input.value, 10);
      const s2 = parseInt(score2Input.value, 10);
      if (isNaN(s1) || isNaN(s2)) {
        matchMessageDiv.textContent = "Enter valid scores.";
        matchMessageDiv.classList.add("error");
        return;
      }
      if (s1 === s2) {
        matchMessageDiv.textContent = "Scores cannot be equal.";
        matchMessageDiv.classList.add("error");
        return;
      }
      if (s1 < 0 || s2 < 0) {
        matchMessageDiv.textContent = "Scores cannot be negative.";
        matchMessageDiv.classList.add("error");
        return;
      }

      const winnerTeam = s1 > s2 ? "team1" : "team2";

      const r1 = teamRating(t1);
      const r2 = teamRating(t2);
      const E1 = expectedScore(r1, r2);
      const E2 = 1 - E1;

      const scoreDiff = Math.abs(s1 - s2);
      const marginFactor = 1 + scoreDiff / 10;

      const S1 = (winnerTeam === "team1") ? 1 : 0;
      const S2 = (winnerTeam === "team2") ? 1 : 0;

      const playerIds = [...t1, ...t2];

      try {
        const docs = await Promise.all(
          playerIds.map(id => db.collection("players").doc(id).get())
        );
        const fresh = {};
        docs.forEach(doc => fresh[doc.id] = { id: doc.id, ...doc.data() });

        const batch = db.batch();
        const playerRatings = {};

        function baseKForPlayer(p) {
          const matchesPlayed = p.matches ?? (p.wins + p.losses);
          return matchesPlayed < 20 ? 64 : 32;
        }

        // Team 1
        t1.forEach(id => {
          const p = fresh[id];
          if (!p) return;
          const before = p.rating ?? BASE_RATING;
          const Kbase = baseKForPlayer(p);
          const kEff = Kbase * marginFactor;
          const after = Math.round(before + kEff * (S1 - E1));
          playerRatings[id] = { before, after, Kbase, kEff };
          batch.update(db.collection("players").doc(id), {
            rating: after,
            wins: p.wins + (S1 ? 1 : 0),
            losses: p.losses + (S1 ? 0 : 1),
            matches: (p.matches ?? (p.wins + p.losses)) + 1
          });
        });

        // Team 2
        t2.forEach(id => {
          const p = fresh[id];
          if (!p) return;
          const before = p.rating ?? BASE_RATING;
          const Kbase = baseKForPlayer(p);
          const kEff = Kbase * marginFactor;
          const after = Math.round(before + kEff * (S2 - E2));
          playerRatings[id] = { before, after, Kbase, kEff };
          batch.update(db.collection("players").doc(id), {
            rating: after,
            wins: p.wins + (S2 ? 1 : 0),
            losses: p.losses + (S2 ? 0 : 1),
            matches: (p.matches ?? (p.wins + p.losses)) + 1
          });
        });

        const matchRef = db.collection("matches").doc();
        batch.set(matchRef, {
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          team1: t1,
          team2: t2,
          winner: winnerTeam,
          score1: s1,
          score2: s2,
          team1RatingBefore: r1,
          team2RatingBefore: r2,
          expected1: E1,
          expected2: E2,
          marginFactor,
          playerRatings
        });

        await batch.commit();
        await logAction("ADD_MATCH", {
          matchId: matchRef.id,
          team1: t1,
          team2: t2,
          winner: winnerTeam,
          score1: s1,
          score2: s2
        });

        predictionDisplay.textContent = "";
        matchMessageDiv.textContent = "Match recorded successfully.";
        matchMessageDiv.classList.add("success");
      } catch (err) {
        console.error(err);
        matchMessageDiv.textContent = "Error recording match: " + err.message;
        matchMessageDiv.classList.add("error");
      }
    });

    // Stats tab
    function fillStatsPlayerSelect() {
      statsPlayerSelect.innerHTML = "<option value=''>-- Select Player --</option>";
      players.forEach(p => {
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.name + " (" + p.rating + ")";
        statsPlayerSelect.appendChild(opt);
      });
    }

    function renderPlayerMatchesTableForCurrentFilter() {
      playerMatchesBody.innerHTML = "";
      if (!statsCurrentPlayerId) return;
      const pid = statsCurrentPlayerId;
      const mode = statsFilterSelect.value;

      statsCurrentMatches
        .slice()
        .sort((a,b) => {
          const ta = a.timestamp?.toMillis ? a.timestamp.toMillis() : 0;
          const tb = b.timestamp?.toMillis ? b.timestamp.toMillis() : 0;
          return tb - ta;
        })
        .forEach(m => {
          const t1 = m.team1 || [];
          const t2 = m.team2 || [];
          const team1Label = teamLabel(t1);
          const team2Label = teamLabel(t2);
          const inTeam1 = t1.includes(pid);
          const teamOfPlayer = inTeam1 ? "team1" : "team2";
          const won = (m.winner === "team1") === (teamOfPlayer === "team1");
          const resultStr = won ? "Win" : "Loss";
          const s1 = m.score1 ?? 0;
          const s2 = m.score2 ?? 0;
          const scoreStr = (m.score1 != null && m.score2 != null)
            ? `${m.score1} - ${m.score2}` : "-";

          let playerScore, oppScore;
          if (teamOfPlayer === "team1") {
            playerScore = s1;
            oppScore = s2;
          } else {
            playerScore = s2;
            oppScore = s1;
          }
          const isShutoutWin = (playerScore > 0 && oppScore === 0);
          const isShutoutLoss = (playerScore === 0 && oppScore > 0);

          if (mode === "shutoutWins" && !isShutoutWin) return;
          if (mode === "shutoutLosses" && !isShutoutLoss) return;

          let ratingAfter = "-";
          if (m.playerRatings && m.playerRatings[pid] && typeof m.playerRatings[pid].after === "number") {
            ratingAfter = m.playerRatings[pid].after;
          }

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${m.timestamp ? timeString(m.timestamp) : ""}</td>
            <td>${team1Label}</td>
            <td>${team2Label}</td>
            <td>${resultStr}</td>
            <td>${scoreStr}</td>
            <td>${ratingAfter}</td>
          `;
          playerMatchesBody.appendChild(tr);
        });
    }

    loadStatsBtn.addEventListener("click", () => {
      statsMessageDiv.textContent = "";
      statsMessageDiv.className = "msg";
      statsSummaryDiv.innerHTML = "";
      playerMatchesBody.innerHTML = "";

      const pid = statsPlayerSelect.value;
      if (!pid) {
        statsMessageDiv.textContent = "Select a player.";
        statsMessageDiv.classList.add("error");
        statsCurrentMatches = [];
        statsCurrentPlayerId = null;
        return;
      }
      const player = players.find(p => p.id === pid);
      if (!player) {
        statsMessageDiv.textContent = "Player not found.";
        statsMessageDiv.classList.add("error");
        statsCurrentMatches = [];
        statsCurrentPlayerId = null;
        return;
      }

      const matchesForPlayer = matchesGlobal.filter(m =>
        (m.team1 || []).includes(pid) ||
        (m.team2 || []).includes(pid)
      );

      let wins = 0;
      let losses = 0;
      let shutoutWins = 0;
      let shutoutLosses = 0;

      matchesForPlayer.forEach(m => {
        const t1 = m.team1 || [];
        const t2 = m.team2 || [];
        const inTeam1 = t1.includes(pid);
        const inTeam2 = t2.includes(pid);
        const s1 = m.score1 ?? 0;
        const s2 = m.score2 ?? 0;

        let teamOfPlayer = inTeam1 ? "team1" : "team2";
        let won = (m.winner === "team1") === (teamOfPlayer === "team1");
        if (won) wins++; else losses++;

        let playerScore, oppScore;
        if (teamOfPlayer === "team1") {
          playerScore = s1;
          oppScore = s2;
        } else {
          playerScore = s2;
          oppScore = s1;
        }
        if (playerScore > 0 && oppScore === 0) shutoutWins++;
        if (playerScore === 0 && oppScore > 0) shutoutLosses++;
      });

      const total = wins + losses;
      const winPercent = total ? ((wins / total) * 100).toFixed(1) + "%" : "0%";

      statsSummaryDiv.innerHTML = `
        <p><b>Player:</b> ${player.name}</p>
        <p><b>Current Player Rating:</b> ${player.rating}</p>
        <p><b>Total Matches:</b> ${total}</p>
        <p><b>Wins:</b> ${wins}</p>
        <p><b>Losses:</b> ${losses}</p>
        <p><b>Winning Percentage:</b> ${winPercent}</p>
        <p><b>Clean Wins (Opponent 0):</b> ${shutoutWins}</p>
        <p><b>Losses to 0 (Scored 0):</b> ${shutoutLosses}</p>
      `;

      statsCurrentMatches = matchesForPlayer;
      statsCurrentPlayerId = pid;
      renderPlayerMatchesTableForCurrentFilter();
    });

    statsFilterSelect.addEventListener("change", () => {
      if (statsCurrentPlayerId) {
        renderPlayerMatchesTableForCurrentFilter();
      }
    });

    // Team Suggestion
    function fillAvailablePlayersSelect() {
      availablePlayersSelect.innerHTML = "";
      players.forEach(p => {
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = `${p.name} (${p.rating})`;
        availablePlayersSelect.appendChild(opt);
      });
    }

    function bestTeamsFromSelection(ids) {
      if (ids.length < 4) return null;
      let best = null;

      for (let i = 0; i < ids.length; i++) {
        for (let j = i+1; j < ids.length; j++) {
          for (let k = j+1; k < ids.length; k++) {
            for (let l = k+1; l < ids.length; l++) {
              const quad = [ids[i], ids[j], ids[k], ids[l]];
              const [a,b,c,d] = quad;

              const partitions = [
                [[a,b],[c,d]],
                [[a,c],[b,d]],
                [[a,d],[b,c]]
              ];
              partitions.forEach(([t1,t2]) => {
                const r1 = teamRating(t1);
                const r2 = teamRating(t2);
                const diff = Math.abs(r1 - r2);
                if (!best || diff < best.diff) {
                  best = { team1:t1, team2:t2, r1, r2, diff };
                }
              });
            }
          }
        }
      }
      return best;
    }

    suggestTeamsBtn.addEventListener("click", () => {
      teamSuggestionDiv.textContent = "";
      teamSuggestionDiv.className = "msg";

      const selected = Array.from(availablePlayersSelect.selectedOptions).map(o => o.value);
      if (selected.length < 4) {
        teamSuggestionDiv.textContent = "Select at least 4 players.";
        teamSuggestionDiv.classList.add("error");
        return;
      }

      const best = bestTeamsFromSelection(selected);
      if (!best) {
        teamSuggestionDiv.textContent = "Could not find a valid combination.";
        teamSuggestionDiv.classList.add("error");
        return;
      }

      const label1 = teamLabel(best.team1);
      const label2 = teamLabel(best.team2);
      const P1 = expectedScore(best.r1, best.r2);
      const P2 = 1 - P1;

      teamSuggestionDiv.innerHTML =
        `<b>Suggested Match:</b><br>` +
        `<b>Team 1:</b> ${label1} (Rating: ${best.r1.toFixed(1)})<br>` +
        `<b>Team 2:</b> ${label2} (Rating: ${best.r2.toFixed(1)})<br>` +
        `<b>Rating diff:</b> ${best.diff.toFixed(1)}<br><br>` +
        `<b>Predicted Winning Chances:</b><br>` +
        `${label1}: ${(P1*100).toFixed(1)}%<br>` +
        `${label2}: ${(P2*100).toFixed(1)}%`;
      teamSuggestionDiv.classList.add("success");
    });

    // Rating Curves
    function fillRatingCurveSelect() {
      ratingCurvePlayerSelect.innerHTML = "<option value=''>-- Select Player --</option>";
      players.forEach(p => {
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.name + " (" + p.rating + ")";
        ratingCurvePlayerSelect.appendChild(opt);
      });
    }

    showCurveBtn.addEventListener("click", () => {
      curveMessageDiv.textContent = "";
      curveMessageDiv.className = "msg";
      const pid = ratingCurvePlayerSelect.value;
      if (!pid) {
        curveMessageDiv.textContent = "Select a player.";
        curveMessageDiv.classList.add("error");
        if (ratingCurveChart) { ratingCurveChart.destroy(); ratingCurveChart = null; }
        return;
      }
      const player = players.find(p => p.id === pid);
      if (!player) {
        curveMessageDiv.textContent = "Player not found.";
        curveMessageDiv.classList.add("error");
        if (ratingCurveChart) { ratingCurveChart.destroy(); ratingCurveChart = null; }
        return;
      }

      const history = [];
      matchesGlobal.forEach(m => {
        if (m.playerRatings && m.playerRatings[pid]) {
          const after = m.playerRatings[pid].after;
          const ts = m.timestamp || null;
          if (typeof after === "number") {
            const tMillis = ts?.toMillis ? ts.toMillis() : null;
            history.push({ rating: after, ts, tMillis });
          }
        }
      });

      if (!history.length) {
        const now = new Date();
        history.push({
          rating: player.rating,
          ts: { toDate: () => now },
          tMillis: now.getTime()
        });
      }

      history.sort((a,b) => (a.tMillis ?? 0) - (b.tMillis ?? 0));

      const labels = history.map(h => h.ts ? timeString(h.ts) : "N/A");
      const data = history.map(h => h.rating);

      if (ratingCurveChart) {
        ratingCurveChart.destroy();
      }

      ratingCurveChart = new Chart(ratingCurveCanvas.getContext("2d"), {
        type: "line",
        data: {
          labels,
          datasets: [{
            label: player.name + " - Player Rating",
            data,
            tension: 0.25
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { title: { display: true, text: "Match Time" } },
            y: { title: { display: true, text: "Player Rating" } }
          }
        }
      });
    });

    // Admin: Edit Player Stats
    function fillEditPlayerSelect() {
      editPlayerSelect.innerHTML = "<option value=''>-- Select Player --</option>";
      players.forEach(p => {
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.name + " (" + p.rating + ")";
        editPlayerSelect.appendChild(opt);
      });
      editPlayerRatingInput.value = "";
      editPlayerWinsInput.value = "";
      editPlayerLossesInput.value = "";
      editPlayerMatchesInput.value = "";
      editPlayerMessageDiv.textContent = "";
      editPlayerMessageDiv.className = "msg";
    }

    editPlayerSelect.addEventListener("change", () => {
      editPlayerMessageDiv.textContent = "";
      editPlayerMessageDiv.className = "msg";
      const pid = editPlayerSelect.value;
      if (!pid) {
        editPlayerRatingInput.value = "";
        editPlayerWinsInput.value = "";
        editPlayerLossesInput.value = "";
        editPlayerMatchesInput.value = "";
        return;
      }
      const p = players.find(x => x.id === pid);
      if (!p) return;
      editPlayerRatingInput.value = p.rating ?? BASE_RATING;
      editPlayerWinsInput.value = p.wins ?? 0;
      editPlayerLossesInput.value = p.losses ?? 0;
      editPlayerMatchesInput.value = p.matches ?? (p.wins + p.losses);
    });

    savePlayerStatsBtn.addEventListener("click", async () => {
      editPlayerMessageDiv.textContent = "";
      editPlayerMessageDiv.className = "msg";
      if (!currentUser) {
        editPlayerMessageDiv.textContent = "Login required.";
        editPlayerMessageDiv.classList.add("error");
        return;
      }
      if (!isAdmin) {
        editPlayerMessageDiv.textContent = "Only admins can edit player stats.";
        editPlayerMessageDiv.classList.add("error");
        return;
      }
      const pid = editPlayerSelect.value;
      if (!pid) {
        editPlayerMessageDiv.textContent = "Select a player.";
        editPlayerMessageDiv.classList.add("error");
        return;
      }

      const rating = parseInt(editPlayerRatingInput.value, 10);
      const wins = parseInt(editPlayerWinsInput.value, 10);
      const losses = parseInt(editPlayerLossesInput.value, 10);
      const matches = parseInt(editPlayerMatchesInput.value, 10);

      if ([rating, wins, losses, matches].some(v => isNaN(v) || v < 0)) {
        editPlayerMessageDiv.textContent = "All values must be non-negative numbers.";
        editPlayerMessageDiv.classList.add("error");
        return;
      }

      try {
        await db.collection("players").doc(pid).update({
          rating,
          wins,
          losses,
          matches
        });
        await logAction("EDIT_PLAYER_STATS", {
          playerId: pid,
          rating,
          wins,
          losses,
          matches
        });
        editPlayerMessageDiv.textContent = "Player stats updated.";
        editPlayerMessageDiv.classList.add("success");
      } catch (err) {
        editPlayerMessageDiv.textContent = "Error updating stats: " + err.message;
        editPlayerMessageDiv.classList.add("error");
      }
    });
  </script>
</body>
</html>
